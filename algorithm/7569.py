# -*- coding: utf-8 -*-
"""7569.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IpjWhsQrqDfKWL_qceJgGKPy8D5-8sCu
"""

# 틀렸습니다 반례 https://www.acmicpc.net/board/view/78471
# 시간초과 참고 https://www.acmicpc.net/board/view/64349, https://www.acmicpc.net/submit/7569/37708336

# python 3로 시간초과 안나고 맞추기
import sys
m, n, h = map(int, sys.stdin.readline().split())
# m 가로(열) n 세로(행) h 높이

# 3차원 그래프 만들기
graph = []

# 이부분을 기억해두기~~! 3차원 배열 만드는 법 
for i in range(h):
    tmp = []
    for j in range(n):
        tmp.append(list(map(int,sys.stdin.readline().split())))
    graph.append(tmp)
      

# bfs
from collections import deque

# 상, 하, 좌, 우, 위, 아래
dx = [-1, 1, 0, 0, 0, 0] 
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, 1, -1]

# k 가로(열) j 세로(행) i 높이
# y 가로(열) x 세로(행) z 높이
# m 가로(열) n 세로(행) h 높이
def bfs(i, j, k, start):
  global m, n, h, day_cnt 
  queue = deque()
  # extend 메소드
  queue.extend(start)

  while queue:
    z, x, y = queue.popleft()

    for a in range(6):
      nz = z + dz[a]
      nx = x + dx[a]
      ny = y + dy[a]
      
      if nz < 0 or nx < 0 or ny <0 or nz>=h or nx>= n or ny >=m:
        continue
      if graph[nz][nx][ny] == -1:
        continue
      if graph[nz][nx][ny] > 1:
        if graph[nz][nx][ny] > graph[z][x][y] + 1:
          graph[nz][nx][ny] = graph[z][x][y] + 1
          queue.append((nz, nx, ny))
      if graph[nz][nx][ny] == 0:
        graph[nz][nx][ny] = graph[z][x][y] + 1
        queue.append((nz, nx, ny))

start = [] # 맨 처음에 1인 위치 찾기

for i in range(h):
  for j in range(n):
    for k in range(m):
      if graph[i][j][k] == 1:
        start.append((i,j,k))

bfs(i,j,k, start)

untomato = False

for i in range(h):
  for j in range(n):
    for k in range(m):
      if graph[i][j][k] == 0:
        untomato = True
        break

if untomato == True:
  print(-1)
else:# 3차원 그래프의 최댓값 구하기
  max_val = graph[0][0][0]
  for i in range(h):
    for j in range(n):
      for k in range(m):
        if max_val < graph[i][j][k]:
          max_val = graph[i][j][k]
  print(max_val-1)

# pypy3로 하면 맞고 python 3으로 하면 시간초과로 틀린 코드 ㅠㅠ

m, n, h = map(int, input().split())
# m 가로(열) n 세로(행) h 높이

# 3차원 그래프 만들기
graph = [[[0 for x in range(m)] for y in range(n)] for z in range(h)]

# 토마토 상자 만들기
# k 가로(열) j 세로(행) i 높이
for i in range(h):
  for j in range(n):
    line = input()
    for k in range(m):
      graph[i][j][k] = int(line.split()[k]) # 자르면 str이므로 int로 바꿔주기
      

# bfs
from collections import deque

# 상, 하, 좌, 우, 위, 아래
dx = [-1, 1, 0, 0, 0, 0] 
dy = [0, 0, -1, 1, 0, 0]
dz = [0, 0, 0, 0, 1, -1]

# k 가로(열) j 세로(행) i 높이
# y 가로(열) x 세로(행) z 높이
# m 가로(열) n 세로(행) h 높이
def bfs(i, j, k, start):
  global m, n, h
  queue = deque()
  # extend 메소드
  queue.extend(start)

  while queue:
    z, x, y = queue.popleft()

    for a in range(6):
      nz = z + dz[a]
      nx = x + dx[a]
      ny = y + dy[a]
      
      # 좌표 벗어가나는 경우
      if nz < 0 or nx < 0 or ny <0 or nz>=h or nx>= n or ny >=m:
        continue
      # 토마토가 들어있지 않은 칸
      if graph[nz][nx][ny] == -1: 
        continue
      # 이미 방문했더라도 다른 토마토와의 위치와 더 가까우면 업데이트
      if graph[nz][nx][ny] > 1:
        if graph[nz][nx][ny] > graph[z][x][y] + 1:
          graph[nz][nx][ny] = graph[z][x][y] + 1
          queue.append((nz, nx, ny))
      # 아직 방문하지 않은 경우(토마토가 익지 않은 경우)
      if graph[nz][nx][ny] == 0:
        graph[nz][nx][ny] = graph[z][x][y] + 1
        queue.append((nz, nx, ny))

# 맨 처음에 1인 위치 찾기
start = []

for i in range(h):
  for j in range(n):
    for k in range(m):
      if graph[i][j][k] == 1:
        start.append((i,j,k))

bfs(i,j,k, start)

# 하나라도 안 익은 토마토가 있는 경우 
untomato = False

for i in range(h):
  for j in range(n):
    for k in range(m):
      if graph[i][j][k] == 0:
        untomato = True
        break

if untomato == True:
  print(-1)
else:# 3차원 그래프의 최댓값 구하기
  max_val = graph[0][0][0]
  for i in range(h):
    for j in range(n):
      for k in range(m):
        if max_val < graph[i][j][k]:
          max_val = graph[i][j][k]
  print(max_val-1)