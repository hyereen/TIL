# -*- coding: utf-8 -*-
"""2468.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CyACFNIHYR-9tSKC2yjtPQvEHwaOErx-
"""

# 2468
# https://www.acmicpc.net/problem/2468

# 꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다
# 인접한다고 취급하면??
# dx dy를 8가지 경우로 바꿔주면 됨

n = int(input())

# 빈 2차원 그래프 만들기
graph = []
for i in range(n):
  graph.append([])

# 지역의 높이 정보 그래프 만들기
for i in range(n):
  tmp_line = input()
  for j in tmp_line.split():
    graph[i].append(int(j))

# 비 높이에 따라 해당영역을 0으로 만들어줌
def make_tmp_grp(graph, rain):
  temp_graph = copy.deepcopy(graph) # 여기서 깊은 복사해줘야 함
  for i in range(n):
    for j in range(n):
      if graph[i][j] <= rain:
        temp_graph[i][j] = 0
  return temp_graph

from collections import deque


dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

import copy


# bfs
def bfs(x, y):
  global n
  # 방문처리
  temp_graph[x][y] = 0
  queue = deque()
  queue.append((x,y))

  while queue:
    w, z = queue.popleft()
    temp_graph[w][z] = 0

    for i in range(4):
        nx = w + dx[i]
        ny = z + dy[i]
        if nx < 0 or nx >= n or ny <0 or ny >=n:
          continue
        if temp_graph[nx][ny] != 0:
          temp_graph[nx][ny] = 0
          queue.append((nx, ny))

safe_cnt = 0
safe_cnt_list = []

for q in range(min(map(min, graph)), max(map(max, graph))+1): # 비가 안오는 경우를 대비해서 0으로 만들어줘야함 
  temp_graph = make_tmp_grp(graph, q)
  safe_cnt = 0 # 새로운 비의 양에 따른 안전 영역 카운트 전에 0으로 만들어줘야 함
  for i in range(n):
    for j in range(n):
      if temp_graph[i][j] != 0:
        bfs(i,j)
        safe_cnt +=1
    safe_cnt_list.append(safe_cnt)      

print(max(safe_cnt_list))