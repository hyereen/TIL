# -*- coding: utf-8 -*-
"""11724.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GjcsVAILBl5H68al6J5dn_aCOopycNmg
"""

# 11724
# https://www.acmicpc.net/problem/11724

import sys
sys.setrecursionlimit(10**6) # 런타임 에러 (RecursionError) 해결

n, m = map(int, sys.stdin.readline().split()) # RecursionError 해결한 뒤에 시간초과 뜨는 거 해결 
graph = []
visited = [False] * (n+1)
ans = 0

# 빈 2차원 리스트 만들기
for i in range(n+1):
  graph.append([])

# 간선 입력받아서 인접리스트 만들기
for i in range(m):
  u, v = map(int, sys.stdin.readline().split())
  graph[u].append(v)
  graph[v].append(u)

# dfs 기본 코드 
def dfs(graph, v, visited):
  visited[v] = True

  for i in graph[v]:
    if visited[i] == False:
      dfs(graph, i, visited)

# 전체 노드를 돌면서 덩어리를 찾기 
for i in range(1, n+1):
  if visited[i] == False:
    dfs(graph, i, visited) # dfs가 끝나면 하나의 덩어리가 완성된다
    ans += 1 # 덩어리의 개수를 더해줌 

print(ans)

# bfs 
import sys # 시간초과 뜨는 거 해결 
from collections import deque # 큐 만들기 위해 

n, m = map(int, sys.stdin.readline().split()) # 시간초과 뜨는 거 해결 
graph = []
visited = [0] * (n+1) 

# 빈 2차원 리스트 만들기
for i in range(n+1):
  graph.append([])

# 간선 입력받아서 인접리스트 만들기
for i in range(m):
  u, v = map(int, sys.stdin.readline().split())
  graph[u].append(v)
  graph[v].append(u)


# bfs
def bfs(v):
  visited[v] = visited[v] + 1
  queue = deque([v])

  while queue:
    i = queue.popleft()
    
    for j in graph[i]:
      if visited[j] == 0:
        visited[j] = visited[i] + 1 # 노드 뎁스에 따라서 1씩 더해준다 
        queue.append(j)

# 전체 노드를 돌면서 덩어리를 찾기 
for i in range(1, n+1):
  if visited[i] == 0: # 0이면 방문을 안했다는 것 
    bfs(i)

print(visited.count(1)) # 1인 노드의 개수가 덩어리의 개수가 된다