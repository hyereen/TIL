# -*- coding: utf-8 -*-
"""1389.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gfmqp26XWicsfFks6TNq-twV0wj9VeWv
"""

# 1389 케빈 베이컨의 6단계 법칙
# https://www.acmicpc.net/problem/1389

# bfs
from collections import deque

n, m = map(int, input().split())

graph = []
visited = [0] * (n+1)
for i in range(n+1):
  graph.append([])

for i in range(m):
  a, b = map(int, input().split())
  graph[a].append(b)
  graph[b].append(a)

# 혹시몰라서 그래프 요소들을 정렬해준다
for i in graph:
  i.sort()

# 기본 bfs
def bfs(v):
  visited[v] += 1
  queue = deque()
  queue.append(v)

  while queue:
    i = queue.popleft()

    for j in graph[i]:
      if visited[j] == 0:
        visited[j] = visited[i] +1
        queue.append(j)

# 케빈베이컨 수 저장하는 리스트
kevin_bacan = []

# 원소별로 bfs를 돌면서 케빈베이컨 값을 구하고 리스트에 저장
for i in range(1, n+1):
  bfs(i)
  kevin_bacan.append(sum(visited)-visited[i]-(n-1)) # visited의 전체 합에서 자기 자신을 빼준 후, 모두 +1씩 되어있으므로 개수만큼 빼준다
  visited = [0] * (n+1)

# 리스트의 0번째가 첫번째 노드이므로 +1을 해준다
print(kevin_bacan.index(min(kevin_bacan))+1)

kevin_bacan.index(5)

min(kevin_bacan)

kevin_bacan

kevin_bacan